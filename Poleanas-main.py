{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "58f0bb17",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']\n",
      "['.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.']\n",
      "['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.']\n",
      "['.', '#', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#', '.', '.', '#', '.']\n",
      "['.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.']\n",
      "['.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.']\n",
      "['.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.']\n",
      "['.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.']\n",
      "['.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.']\n",
      "['.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.']\n",
      "['.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.']\n",
      "['.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.']\n",
      "['.', '#', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#', '.', '.', '#', '.']\n",
      "['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.']\n",
      "['.', '.', '.', '#', '#', '.', '.', '.', '.', '.', '.', '#', '#', '.', '.', '.']\n",
      "['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']\n"
     ]
    }
   ],
   "source": [
    "from collections import deque as deque\n",
    "\n",
    "class Laberinto:\n",
    "    \n",
    "    def __init__(self, renglones, cols, ruta):\n",
    "        self.ruta = ruta\n",
    "        self.laberinto = self.leer_txt()\n",
    "        self.renglones, self.cols = renglones, cols\n",
    "        #self.laberinto = []\n",
    "        #for i in range(self.renglones):\n",
    "            #self.laberinto.append([x for x in input()])\n",
    "\n",
    "        #lineas de IA\n",
    "        #self.x1, self.y1 = [int(x) for x in input().split()]\n",
    "        #self.x2, self.y2 = [int(x) for x in input().split()]\n",
    "        #self.laberinto[self.x1-1][self.y1-1] = 'O'\n",
    "        #self.laberinto[self.x2-1][self.y2-1] = 'D'\n",
    "\n",
    "    def leer_txt(self):\n",
    "        with open(self.ruta, \"r\", encoding=\"utf-8\") as archivo:\n",
    "            return [list(linea.strip()) for linea in archivo]\n",
    "\n",
    "    def tablero_personalizado():\n",
    "        renglones, cols = [int(x) for x in input(\"introduzca las dimensiones del eje x y del eje y separadas por un espacio\").split()]\n",
    "        Tablero=Laberinto(renglones, cols)\n",
    "\n",
    "    def bfs(self):#Búsqueda en anchura\n",
    "\n",
    "        self.cola = deque()\n",
    "        self.visitados = set()\n",
    "\n",
    "        #posiciones iniciales\n",
    "        nodo = (self.x1 - 1, self.y1 - 1)\n",
    "        self.cola.append((nodo, \"\"))  # (posición inicial, camino inicial)\n",
    "        self.visitados.add(nodo) #marcamos como visitado el nodo inicial\n",
    "\n",
    "        # Movimientos en sentido horario: derecha, abajo, izquierda, arriba\n",
    "        direcciones = [(0, 1, \"R\"), (1, 0, \"D\"), (0, -1, \"L\"), (-1, 0, \"U\")]\n",
    "        if self.x1 == self.x2 and self.y1 == self.y2:\n",
    "            return (\"\") \n",
    "\n",
    "        while self.cola: #ciclo mientras haya nodos en la cola\n",
    "            (x, y), camino = self.cola.popleft() \n",
    "            if self.laberinto[x][y] == 'D':\n",
    "                return camino\n",
    "\n",
    "            for dx, dy, mov in direcciones: #exploramos en las 4 direcciones\n",
    "                nx, ny = x + dx, y + dy\n",
    "                if 0 <= nx < self.renglones and 0 <= ny < self.cols:\n",
    "                    nodo = self.laberinto[nx][ny]\n",
    "                    if nodo != '#' and (nx, ny) not in self.visitados:\n",
    "                        self.cola.append(((nx, ny), camino + mov))\n",
    "                        self.visitados.add((nx, ny))\n",
    "\n",
    "        return \"no hay solucion\"  # si no se encuentra camino\n",
    "\n",
    "                    \n",
    "\n",
    "    def imprimir_laberinto(self): #imprime el laberinto\n",
    "        for i in range(self.renglones):\n",
    "            print(self.laberinto[i])\n",
    "\n",
    "    def imprimir_camino(self): #imprime el camino y la longitud del mismo\n",
    "        camino = self.bfs()\n",
    "        print(camino)\n",
    "        print(int(len(self.visitados))-1)\n",
    "        \n",
    "            \n",
    "       \n",
    "\n",
    "x,y=16,16\n",
    "Poleana= Laberinto(x,y,\"TABLERO.txt\")\n",
    "Poleana.imprimir_laberinto()  \n",
    "#Laberinto1.imprimir_camino()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bfecd522",
   "metadata": {},
   "source": [
    "#######\n",
    "#..#..#\n",
    "##.#.##\n",
    "#.....#\n",
    "#.##..#\n",
    "#..##.#\n",
    "##..#.#\n",
    "##.##.#\n",
    "#...#.D\n",
    "O.#.###\n",
    "#######"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.14.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
