{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "58f0bb17",
   "metadata": {},
   "outputs": [
    {
     "ename": "ImportError",
     "evalue": "internal Python C API version mismatch: module _tkinter compiled with 3.14.3; runtime version is 3.14.2",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mImportError\u001b[39m                               Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[32]\u001b[39m\u001b[32m, line 3\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mcollections\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m deque \u001b[38;5;28;01mas\u001b[39;00m deque\n\u001b[32m      2\u001b[39m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mmatplotlib\u001b[39;00m\u001b[34;01m.\u001b[39;00m\u001b[34;01mpyplot\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mas\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mplt\u001b[39;00m\n\u001b[32m----> \u001b[39m\u001b[32m3\u001b[39m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mtkinter\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mas\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mtk\u001b[39;00m\n\u001b[32m      4\u001b[39m root = tk.Tk()\n\u001b[32m      5\u001b[39m root.title(\u001b[33m\"\u001b[39m\u001b[33mTest\u001b[39m\u001b[33m\"\u001b[39m)\n",
      "\u001b[36mFile \u001b[39m\u001b[32m/usr/lib64/python3.14/tkinter/__init__.py:38\u001b[39m\n\u001b[32m     35\u001b[39m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01msys\u001b[39;00m\n\u001b[32m     36\u001b[39m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mtypes\u001b[39;00m\n\u001b[32m---> \u001b[39m\u001b[32m38\u001b[39m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01m_tkinter\u001b[39;00m \u001b[38;5;66;03m# If this fails your Python may not be configured for Tk\u001b[39;00m\n\u001b[32m     39\u001b[39m TclError = _tkinter.TclError\n\u001b[32m     40\u001b[39m \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mtkinter\u001b[39;00m\u001b[34;01m.\u001b[39;00m\u001b[34;01mconstants\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m *\n",
      "\u001b[31mImportError\u001b[39m: internal Python C API version mismatch: module _tkinter compiled with 3.14.3; runtime version is 3.14.2"
     ]
    }
   ],
   "source": [
    "from collections import deque as deque\n",
    "import matplotlib.pyplot as plt\n",
    "import tkinter as tk\n",
    "root = tk.Tk()\n",
    "root.title(\"Test\")\n",
    "root.mainloop()\n",
    "\n",
    "class Laberinto:\n",
    "    \n",
    "    def __init__(self, renglones, cols, ruta_txt, ruta_png):\n",
    "        \n",
    "        self.ruta_txt = ruta_txt\n",
    "        self.laberinto = self.leer_txt()\n",
    "        self.ruta_png = ruta_png\n",
    "        self.imagen = self.leer_imagen()\n",
    "        self.renglones, self.cols = renglones, cols\n",
    "        self.ajustar_puertas()\n",
    "\n",
    "        #Lineas paara crear laberinto renglon por renglon.\n",
    "        \n",
    "        #self.laberinto = []\n",
    "        #for i in range(self.renglones):\n",
    "            #self.laberinto.append([x for x in input()])\n",
    "\n",
    "        #lineas de IA\n",
    "        self.x1, self.y1 = [int(x) for x in input().split()]\n",
    "        self.x2, self.y2 = [int(x) for x in input().split()]\n",
    "        self.laberinto[self.x1-1][self.y1-1] = 'O'\n",
    "        self.laberinto[self.x2-1][self.y2-1] = 'D'\n",
    "\n",
    "    def leer_txt(self):\n",
    "        with open(self.ruta_txt, \"r\", encoding=\"utf-8\") as archivo:\n",
    "            return [list(linea.strip()) for linea in archivo]\n",
    "\n",
    "    def leer_imagen(self):\n",
    "        return plt.imread(self.ruta_png)\n",
    "\n",
    "    def ajustar_puertas(self):\n",
    "    # Fila 2, columnas 6 a 10\n",
    "        for col in range(5, 10):\n",
    "            self.laberinto[1][col] = '.'\n",
    "\n",
    "    # Fila 15, columnas 6 a 10\n",
    "        for col in range(5, 10):\n",
    "            self.laberinto[14][col] = '.'\n",
    "    \n",
    "    def tablero_personalizado():\n",
    "        renglones, cols = [int(x) for x in input(\"introduzca las dimensiones del eje x y del eje y separadas por un espacio\").split()]\n",
    "        Tablero=Laberinto(renglones, cols)\n",
    "        \n",
    "    def bfs(self):\n",
    "\n",
    "    \n",
    "        plt.ion()  # ðŸ”¥ activar modo interactivo\n",
    "    \n",
    "        cola = deque()\n",
    "        visitados = set()\n",
    "    \n",
    "        nodo = (self.x1 - 1, self.y1 - 1)\n",
    "        cola.append(nodo)\n",
    "        visitados.add(nodo)\n",
    "    \n",
    "        direcciones = [(0,1), (1,0), (0,-1), (-1,0)]\n",
    "    \n",
    "        fig, ax = plt.subplots()\n",
    "    \n",
    "        ax.imshow(self.imagen, extent=[0, self.cols, self.renglones, 0])\n",
    "        ax.set_xticks(range(self.cols + 1))\n",
    "        ax.set_yticks(range(self.renglones + 1))\n",
    "        ax.grid(True)\n",
    "        ax.set_aspect('equal')\n",
    "    \n",
    "        fig.canvas.draw()\n",
    "    \n",
    "        while cola:\n",
    "            x, y = cola.popleft()\n",
    "    \n",
    "            rect = plt.Rectangle((y, x), 1, 1,\n",
    "                                 facecolor='lime',\n",
    "                                 alpha=0.6)\n",
    "            ax.add_patch(rect)\n",
    "    \n",
    "            fig.canvas.draw()\n",
    "            fig.canvas.flush_events()\n",
    "            plt.pause(0.05)\n",
    "    \n",
    "            if self.laberinto[x][y] == 'D':\n",
    "                print(\"Destino encontrado\")\n",
    "                break\n",
    "    \n",
    "            for dx, dy in direcciones:\n",
    "                nx, ny = x + dx, y + dy\n",
    "    \n",
    "                if 0 <= nx < self.renglones and 0 <= ny < self.cols:\n",
    "                    if self.laberinto[nx][ny] != '#' and (nx, ny) not in visitados:\n",
    "                        cola.append((nx, ny))\n",
    "                        visitados.add((nx, ny))\n",
    "    \n",
    "        plt.ioff()\n",
    "        plt.show()\n",
    "    \n",
    "    def bfs1(self):#BÃºsqueda en anchura\n",
    "\n",
    "        self.cola = deque()\n",
    "        self.visitados = set()\n",
    "\n",
    "        #posiciones iniciales\n",
    "        nodo = (self.x1 - 1, self.y1 - 1)\n",
    "        self.cola.append((nodo, \"\"))  # (posiciÃ³n inicial, camino inicial)\n",
    "        self.visitados.add(nodo) #marcamos como visitado el nodo inicial\n",
    "\n",
    "        # Movimientos en sentido horario: derecha, abajo, izquierda, arriba\n",
    "        direcciones = [(0, 1, \"R\"), (1, 0, \"D\"), (0, -1, \"L\"), (-1, 0, \"U\")]\n",
    "        if self.x1 == self.x2 and self.y1 == self.y2:\n",
    "            return (\"\") \n",
    "\n",
    "        while self.cola: #ciclo mientras haya nodos en la cola\n",
    "            (x, y), camino = self.cola.popleft() \n",
    "            if self.laberinto[x][y] == 'D':\n",
    "                return camino\n",
    "\n",
    "            for dx, dy, mov in direcciones: #exploramos en las 4 direcciones\n",
    "                nx, ny = x + dx, y + dy\n",
    "                if 0 <= nx < self.renglones and 0 <= ny < self.cols:\n",
    "                    nodo = self.laberinto[nx][ny]\n",
    "                    if nodo != '#' and (nx, ny) not in self.visitados:\n",
    "                        self.cola.append(((nx, ny), camino + mov))\n",
    "                        self.visitados.add((nx, ny))\n",
    "\n",
    "        return \"no hay solucion\"  # si no se encuentra camino\n",
    "\n",
    "    def imprimir_laberinto(self):\n",
    "        for i in range(self.renglones):\n",
    "            print(self.laberinto[i])\n",
    "    \n",
    "        fig, ax = plt.subplots()\n",
    "    \n",
    "        ax.imshow(self.imagen, extent=[0, self.cols, self.renglones, 0])\n",
    "    \n",
    "        ax.set_xticks(range(self.cols + 1))\n",
    "        ax.set_yticks(range(self.renglones + 1))\n",
    "        ax.grid(True)\n",
    "        ax.set_aspect('equal')\n",
    "    \n",
    "        # ðŸ”¥ Dibujar paredes\n",
    "        for i in range(self.renglones):\n",
    "            for j in range(self.cols):\n",
    "                if self.laberinto[i][j] == '#':\n",
    "                    ax.add_patch(\n",
    "                        plt.Rectangle((j, i), 1, 1,\n",
    "                                      fill=False,\n",
    "                                      edgecolor='red',\n",
    "                                      linewidth=2)\n",
    "                    )\n",
    "    \n",
    "        plt.show()\n",
    "\n",
    "                    \n",
    "\n",
    "    #def imprimir_laberinto(self):\n",
    "     #   for i in range(self.renglones):\n",
    "      #      print(self.laberinto[i])\n",
    "       # \n",
    "        #plt.imshow(self.imagen, extent=[0,16,16,0])\n",
    "        #plt.xticks(range(17))\n",
    "        #plt.yticks(range(17))\n",
    "        #plt.grid(True)\n",
    "        #self.ajustar_puertas()#plt.axis(\"off\")\n",
    "        #plt.show()\n",
    "\n",
    "    \n",
    "    \n",
    "    def imprimir_camino(self): #imprime el camino y la longitud del mismo\n",
    "        camino = self.bfs()\n",
    "        print(camino)\n",
    "        print(int(len(self.visitados))-1)\n",
    "        \n",
    "            \n",
    "       \n",
    "\n",
    "x,y=16,16\n",
    "Poleana= Laberinto(x,y,\"TABLERO.txt\", \"poleana-1.png\")\n",
    "Poleana.imprimir_laberinto()  \n",
    "Poleana.bfs()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8f9444fb-a666-4a6c-a6eb-0b25694d67b3",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.19"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
